# Generic Types

<EpicVideo url="https://www.epicweb.dev/workshops/type-safety/6-generics/generic-types" />

ğŸ‘¨â€ğŸ’¼ Generics aren't just for functionsâ€”you can create reusable, generic **types**
and **interfaces** too!

```ts
// Generic type alias
type Container<Value> = {
	value: Value
}

// Generic interface
interface Box<Contents> {
	contents: Contents
}

// Usage
const stringBox: Box<string> = { contents: 'hello' }
const numberBox: Box<number> = { contents: 42 }
```

This is exactly how built-in types like `Array<Item>` and `Promise<ResponseData>`
work.

ğŸ¦‰ Avoid using generics to hide a cast. This is a common anti-pattern:

```ts
// âŒ Bad: the caller picks the type, not the data
function getData<Data>(): Data {
	return fetchData() as Data
}

const user = getData<User>() // Compiles even if fetchData returns wrong shape!
```

This compiles even if the actual data is the wrong shape, which defeats the
purpose of TypeScript. Instead, you should actually validate the data and use
type guards to ensure the data is the correct shape.

ğŸ¨ Open <InlineFile file="index.ts" /> and:

1. Create a generic `LoadingState<Data>` type for async operations
2. Create helper functions `createSuccess<Data>` and `createError<Data>`
3. See how TypeScript narrows the type based on the discriminated union

ğŸ’° Model idle, loading, success, and error states with a generic discriminated union.

ğŸ“œ [TypeScript Handbook - Generic Types](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-types)
