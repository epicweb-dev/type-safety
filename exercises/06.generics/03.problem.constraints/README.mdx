# Generic Constraints

üë®‚Äçüíº Sometimes you need to limit what types can be used with a generic. For
example, a function that accesses `.length` only works with types that have a
`length` property.

```ts
// ‚ùå Error: Value might not have .length
function logLength<Value>(value: Value) {
	console.log(value.length)
}

// ‚úÖ Constrain Value to types with length
function logLength<Value extends { length: number }>(value: Value) {
	console.log(value.length) // Safe!
}

logLength('hello') // ‚úÖ strings have length
logLength([1, 2, 3]) // ‚úÖ arrays have length
logLength(42) // ‚ùå Error: number has no length
```

Use `extends` to add constraints.

üê® Open <InlineFile file="index.ts" /> and:

1. Create a constrained function that requires objects with an `id` property
2. Use `keyof` constraint for type-safe property access (we'll cover type operators in depth in the Advanced TypeScript workshop)
3. Create a function with multiple constrained type parameters

<callout-info>
	This is a small preview of **type operators**. We'll dive deeper into these in
	the Advanced TypeScript workshop.

    `keyof ObjectType` produces a union of all property names of type ObjectType.
    For example, if ObjectType is `{ name: string; age: number }`, then
    `keyof ObjectType` is `'name' | 'age'`.

    `ObjectType[Key]` is an **indexed access type** - it gives you the type of
    property Key on type ObjectType. If ObjectType is `{ name: string }` and Key
    is `'name'`, then `ObjectType[Key]` is `string`.

</callout-info>

üìú [TypeScript Handbook - Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
