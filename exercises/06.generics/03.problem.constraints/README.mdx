# Generic Constraints

ğŸ‘¨â€ğŸ’¼ Sometimes you need to limit what types can be used with a generic. For
example, a function that accesses `.length` only works with types that have a
`length` property.

```ts
// âŒ Error: Value might not have .length
function logLength<Value>(value: Value) {
	console.log(value.length)
}

// âœ… Constrain Value to types with length
function logLength<Value extends { length: number }>(value: Value) {
	console.log(value.length) // Safe!
}

logLength('hello') // âœ… strings have length
logLength([1, 2, 3]) // âœ… arrays have length
logLength(42) // âŒ Error: number has no length
```

Use `extends` to add constraints.

ğŸ¨ Open <InlineFile file="index.ts" /> and:

1. Create a constrained function that requires objects with an `id` property
2. Create a function constrained to types with a `name` property
3. Use `keyof` constraint for type-safe property access (weâ€™ll cover type operators in depth in the Advanced TypeScript workshop)
4. Create a function with multiple constrained type parameters

<callout-info>
	This is a small preview of **type operators**. Weâ€™ll dive deeper into these in
	the Advanced TypeScript workshop.

    `keyof ObjectType` produces a union of all property names of type ObjectType.
    For example, if ObjectType is `{ name: string; age: number }`, then
    `keyof ObjectType` is `'name' | 'age'`.

    `ObjectType[Key]` is an **indexed access type** - it gives you the type of
    property Key on type ObjectType. If ObjectType is `{ name: string }` and Key
    is `'name'`, then `ObjectType[Key]` is `string`.

</callout-info>

ğŸ“œ [TypeScript Handbook - Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
