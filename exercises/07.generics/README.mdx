# Generics

Generics are one of TypeScript's most powerful features. They let you write
**reusable code** that works with multiple types while maintaining type safety.

```ts
// Without generics - only works with numbers
function firstNumber(arr: number[]): number | undefined {
	return arr[0]
}

// With generics - works with ANY type
function first<T>(arr: T[]): T | undefined {
	return arr[0]
}

first([1, 2, 3]) // T is number, returns number | undefined
first(['a', 'b']) // T is string, returns string | undefined
```

## The Problem Generics Solve

Without generics, you'd need to either:

1. **Write duplicate code** for each type
2. **Use `any`** and lose type safety

```ts
// Bad: Duplicated code
function firstString(arr: string[]): string | undefined { ... }
function firstNumber(arr: number[]): number | undefined { ... }
function firstUser(arr: User[]): User | undefined { ... }

// Bad: Loses type safety
function first(arr: any[]): any { ... }

// Good: Generic - type-safe and reusable
function first<T>(arr: T[]): T | undefined { ... }
```

## Generics Are Everywhere

You've already been using generics! `Array<T>`, `Promise<T>`, and many more:

```ts
const numbers: Array<number> = [1, 2, 3]
const promise: Promise<string> = fetch('/api').then((r) => r.text())
```

<callout-info>
	Think of generics as "type parameters"â€”just like function parameters let you
	pass in values, generics let you pass in types.
</callout-info>

In this exercise, you'll learn to write and use generic code.
