# Generic Constraints

ğŸ‘¨â€ğŸ’¼ Sometimes you need to limit what types can be used with a generic. For
example, a function that accesses `.length` only works with types that have a
`length` property.

```ts
// âŒ Error: T might not have .length
function logLength<T>(value: T) {
	console.log(value.length)
}

// âœ… Constrain T to types with length
function logLength<T extends { length: number }>(value: T) {
	console.log(value.length) // Safe!
}

logLength('hello') // âœ… strings have length
logLength([1, 2, 3]) // âœ… arrays have length
logLength(42) // âŒ Error: number has no length
```

Use `extends` to add constraints.

ğŸ¨ Open <InlineFile file="index.ts" /> and:

1. Create a constrained function that requires objects with an `id` property
2. Create a function constrained to types with a `name` property
3. Use `keyof` constraint for type-safe property access
4. Create a function with multiple constrained type parameters

ğŸ’° Constraining to objects with specific properties:

```ts
function getProperty<T extends { id: string }>(obj: T): string {
	return obj.id
}
```

ğŸ’° Using `keyof` for property access:

```ts
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
	return obj[key]
}
```

<callout-info>
	`keyof T` produces a union of all property names of type T. For example, if T
	is `{ name: string; age: number }`, then `keyof T` is `'name' | 'age'`.

    `T[K]` is an **indexed access type** - it gives you the type of property K on
    type T. If T is `{ name: string }` and K is `'name'`, then `T[K]` is `string`.

</callout-info>

ğŸ“œ [TypeScript Handbook - Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)

ğŸ¨ Once you've completed the exercise, run `node index.ts` in the playground to test your work!
