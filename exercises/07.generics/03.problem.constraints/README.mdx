# Generic Constraints

ğŸ‘¨â€ğŸ’¼ Sometimes you need to limit what types can be used with a generic. For
example, a function that accesses `.length` only works with types that have a
`length` property.

```ts
// âŒ Error: T might not have .length
function logLength<T>(value: T) {
	console.log(value.length)
}

// âœ… Constrain T to types with length
function logLength<T extends { length: number }>(value: T) {
	console.log(value.length) // Safe!
}

logLength('hello') // âœ… strings have length
logLength([1, 2, 3]) // âœ… arrays have length
logLength(42) // âŒ Error: number has no length
```

Use `extends` to add constraints.

ğŸ¨ Open <InlineFile file="index.ts" /> and:

1. Create a constrained function that requires objects with an `id` property
2. Create a function constrained to types with a `name` property
3. Use `keyof` constraint for type-safe property access (weâ€™ll cover type operators in depth in the Advanced TypeScript workshop)
4. Create a function with multiple constrained type parameters


<callout-info>
	This is a small preview of **type operators**. Weâ€™ll dive deeper into these in
	the Advanced TypeScript workshop.

	`keyof T` produces a union of all property names of type T. For example, if T
	is `{ name: string; age: number }`, then `keyof T` is `'name' | 'age'`.

    `T[K]` is an **indexed access type** - it gives you the type of property K on
    type T. If T is `{ name: string }` and K is `'name'`, then `T[K]` is `string`.

</callout-info>

ğŸ“œ [TypeScript Handbook - Generic Constraints](https://www.typescriptlang.org/docs/handbook/2/generics.html#generic-constraints)
